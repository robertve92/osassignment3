Design decisions
 - Synchronizing consumers with the producer
 	- Buffer slot validity
 	- Buffer slot availability
 	- Starting consumers
 - Synchronizing consumers with eachother

1. Synchronizing consumers with the producer
	The output from consumers and producer must be synchronized so that a consumer cannot say that it has consumed an item before the producers says it has created it. This can easily be guaranteed by using a mutex for outputting in all threads
	The buffer is shared among all consumers and the producer. Because consumers only read from the buffer they do not necessarily need to be excluded from eachother. But the producer may not write values to the buffer while consumers are reading from it because this leads to undefined behavior. We guarantee that this does not occur by means of a mutex and a bitmap which keeps track of the validity of all elements in the buffer. The bitmap is also shared among all threads and thus requires the same mutex. The producer assert an element of the bitmap when it produced an item and the consumer deasserts the same when element when it consumed the item.
	For these three issues, only one mutex is used which excludes critical sections from the producer and consumers.
	The producers needs to know if there are entries available in the buffer but it is not allowed to busy wait and check this. We consider the number of available slots in the buffer as a finite resource and use a semaphore to block the producer when the buffer is full.
	After the producer has written an item to the buffer, it will loop through the buffer to see which item has the lowest sequence number. The producer will alert the consumer that should consume this item by asserting a binary semephore.

2. Synchronizing consumers with eachother
	Consumers should be synchronized because the buffer is a FIFO buffer. The oldest item in the buffer must be consumed first by a specific consumer. This means that at any given time there can only be one item consumed which can only be consumed by one consumer. In order to efficiently signal a specific consumer that it should consume an item without spinlocking, every consumer is assigned a unique binary semaphore. A binary semaphore is not part of semaphore.h library so we had to create it ourselves using a mutex and a condition variable. All consumers and the producer can post to the samephore. As already mentioned, the producer checks the buffer for the oldest element and signals a consumer, the consumers do the exact same thing. When a consumer has found the oldest element in the buffer it will enter a while loop which checks if the item is meant for this consumer. If it is, the item is consumed and the while loop checks the next item which must also be the next oldest item because the buffer is circular. If the item is meant for another consumer, the consumer will drop the mutex and signal the appropriate consumer. This way there is always a consumer consuming items from the buffer or a queue of consumers waiting to consume items. This queue is not necessarily in the right order, meaning that the next consumer in line is not guaranteed to be able to consume. This is not a problem, however, because the right consumer must be waiting to receive the mutex lock because it got one or more signals from the producer or other consumers. So deadlock will not occur in any mutex scheduling policy.