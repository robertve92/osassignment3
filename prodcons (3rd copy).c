/* 
 * Operating Systems  (2IN05)  Practical Assignment
 * Condition Variables Application
 *
 * STUDENT_NAME_1 (STUDENT_NR_1)
 * STUDENT_NAME_2 (STUDENT_NR_2)
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <pthread.h>
#include <semaphore.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM   buffer [BUFFER_SIZE];

static bool   bitmap [BUFFER_SIZE];

static unsigned int nrof_consumers = NROF_CONSUMERS;

static int prev = -1, next = -1;

static bool done = false, first = true;

static bool waiting[NROF_CONSUMERS];

struct ThreadData
{
    int id;
    bool critical;
};

struct bin_sem {
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int v;
};

void binsem_init(struct bin_sem *p, int init_val)
{
    pthread_mutex_lock(&p->mutex);
    if (init_val > 0)
        p->v = 1;
    else if (init_val < 1)
        p->v = 0;
    pthread_mutex_unlock(&p->mutex);
}

void binsem_post(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    if (p->v == 0)
        p->v += 1;
    pthread_cond_signal(&p->cond);
    pthread_mutex_unlock(&p->mutex);
}

void binsem_depost(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    if (p->v == 1)
        p->v -= 1;
    pthread_cond_signal(&p->cond);
    pthread_mutex_unlock(&p->mutex);
}

void binsem_wait(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    while (!p->v)
        pthread_cond_wait(&p->cond, &p->mutex);
    p->v -= 1;
    pthread_mutex_unlock(&p->mutex);
}

pthread_cond_t cond_var[NROF_CONSUMERS];
pthread_cond_t cond_rdy[NROF_CONSUMERS];
pthread_cond_t cond_wait;
pthread_mutex_t mutex_prod;
pthread_mutex_t mutex_wait;
sem_t sem, sem_pool;

struct bin_sem * binsem_cons[NROF_CONSUMERS];

static void * producer (void * arg);
static void * consumer (void * arg);
static void rsleep (int t);

int main (void)
{
	printf("Producer / consumer 0.0.0\n");
	printf("%d Consumers\n", nrof_consumers);

	pthread_t p_producer;
	pthread_t p_consumer[nrof_consumers];
	int i;

    struct ThreadData * threadData[nrof_consumers];
    // allocate memory for thread data
    for( i = 0 ; i < nrof_consumers ; i++ )
    {
        //cond_var[i] = calloc(nrof_consumers, sizeof(pthread_cond_t));
        threadData[i] = calloc(nrof_consumers, sizeof(struct ThreadData)); 
        threadData[i]->id = i;
        threadData[i]->critical = false;
        fprintf(stderr, "Setting binsem %d\n", i);
        binsem_init(&binsem_cons[i], 1);
    }

    for ( i = 0; i < BUFFER_SIZE; i++ )
    {
        bitmap[i] = false;
    }

    sem_init(&sem, false, BUFFER_SIZE);
    sem_init(&sem_pool, false, nrof_consumers);

    /////////////////////////////////////////////
    // create threads
	pthread_create(&p_producer, NULL, producer, threadData);
	for (i = 0; i < nrof_consumers; i++)
	{
        waiting[i] = false;
		pthread_create(&p_consumer[i], NULL, consumer, threadData[i]);
	}
    /////////////////////////////////////////////
    // clean up threads
	int er = 0;
	if ( (er = pthread_join (p_producer, NULL ) ) != 0 )
	{
		perror("Error joining producer thread");
	}
    else
    {
        fprintf(stderr, "Producer joined %lx\n", p_producer);
    }
	for (i = 0; i < nrof_consumers; i++)
	{
		if ( ( er = pthread_join(p_consumer[i], NULL ) != 0 ) )
		{
			perror("Error joining consumer thread");
		}
        else
        {
            fprintf(stderr, "Consumer joined %lx, i: %d\n", p_consumer[i], i);
        }
	}  
    
    return (0);
}


/* producer thread */
static void * producer (void * arg)
{
	printf("Producer started %lx\n", pthread_self());
    ITEM    item;   // a produced item
    unsigned int count = 0, i, last = NROF_ITEMS + 1, ind;
    
    while (1/* TODO: not all items produced */)
    {

        rsleep (PRODUCER_SLEEP_FACTOR);
        
        item = random () % nrof_consumers;
        item |= (count << 8);

        // wait until there is room in the buffer
        fprintf(stderr, "P waits for sem\n");
        sem_wait(&sem);
        fprintf(stderr, "P waits for mutex\n");
        pthread_mutex_lock(&mutex_prod);
        fprintf(stderr, "P passed mutex\n");
        //fprintf(stderr, "item %04x, %x, %x\n",item, (item & (255 << 8)) >> 8, item & 255 );
        buffer[((item & (255 << 8)) >> 8) % BUFFER_SIZE] = item;
        bitmap[((item & (255 << 8)) >> 8) % BUFFER_SIZE] = true;
        fprintf(stderr, "P written to buffer\n");
        last = NROF_ITEMS + 1;
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {// check if there is an older item in the buffer
            if ( ((buffer[i] & (255 << 8)) >> 8) < last && bitmap[i])
            {
                last = (buffer[i] & (255 << 8)) >> 8;
                ind = i;
            }
        }

        fprintf(stderr, "P checking critical threads\n");
        
        if (!((struct ThreadData **) arg)[buffer[ind] & 255]->critical)
        {
            prev = -1;
            fprintf(stderr, "P signalling...\n");
            pthread_cond_signal(&cond_var[(buffer[ind] & 255)]);
            fprintf(stderr, "P signalled C%d, last %d\n", buffer[ind] & 255, last);
            first = false;
        }
        
        fprintf(stderr, "P dropping mutex\n");
        pthread_mutex_unlock(&mutex_prod);
        fprintf(stderr, "P dropped mutex\n");

        printf("%04x\n", item); // write info to stdout
        if ( count++ == NROF_ITEMS )
        {
            break;
        }
    }

    while (!done)
    {
        last = NROF_ITEMS + 1;
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {// check if there is an older item in the buffer
            if ( ((buffer[i] & (255 << 8)) >> 8) < last && bitmap[i])
            {
                last = (buffer[i] & (255 << 8)) >> 8;
                ind = i;
            }
        }
        if (!((struct ThreadData **) arg)[buffer[ind] & 255]->critical)
        {
            prev = -1;
            pthread_cond_signal(&cond_var[buffer[ind] & 255]);
            fprintf(stderr, "P signalled C%d, last %d\n", buffer[ind] & 255, last);
            first = false;
        }
    }
    printf("Producer stopped %lx\n", pthread_self());
    pthread_exit(NULL);
    // TODO: inform consumers that we're ready
}

/* consumer thread */
static void * consumer (void * arg)
{
	printf("Consumer started %lx\n", pthread_self());
    ITEM    item;   // a consstatic void * producer (void * arg)umed item
    int     id = ((struct ThreadData *) arg)->id;
    int     i, ind, semval;
    unsigned short int last = NROF_ITEMS + 1;

    
    while (1/* TODO: not all items retrieved for this customer */)
    {
        
        rsleep (100 * nrof_consumers);
        last = NROF_ITEMS + 1;
        if (done)
            break;
        fprintf(stderr, "C%d waits for mutex\n", id);
        pthread_mutex_lock(&mutex_prod);
        if (done)
            break;

        fprintf(stderr, "C%d posting binsem\n", id);
        //binsem_post(&binsem_cons[id]);
        fprintf(stderr, "C%d waits for cond\n", id);
        pthread_cond_wait(&cond_var[id], &mutex_prod);
        fprintf(stderr, "C%d deposting binsem\n", id);
        //binsem_depost(&binsem_cons[id]);

        waiting[id] = false;
        
        fprintf(stderr, "C%d critical after C%d\n", id, prev);
        ((struct ThreadData *) arg)->critical = true;

        // print all contents of the buffer
        fprintf(stderr, "       Buffer contents:\n");
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if (bitmap[i])
            {
                fprintf(stderr, "       %04x %x\n", buffer[i], (buffer[i] & (255 << 8)) >> 8);
            }
            else
            {
                fprintf(stderr, "       -111\n");
            }
        }

        // check if there is an older item in the buffer
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if ( ((buffer[i] & (255 << 8)) >> 8) < last && bitmap[i])
            {
                last = (buffer[i] & (255 << 8)) >> 8;
                ind = i;
                fprintf(stderr, "                     C%d checked %04x, last: %d\n", id, buffer[i], last);
            }
        }

        // if the next item is also for this consumer
        while (( buffer[ind] & 255 ) == id && bitmap[ind])
        {
            item = buffer[ind];
            bitmap[ind] = false;
            printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
            sem_post(&sem);
            ind = (ind + 1) % BUFFER_SIZE;
        }
        
        // if this was the last item
        if ( ( (item & (255 << 8)) >> 8 ) == NROF_ITEMS )
        {
            done = true;
            for ( i = 0; i < nrof_consumers; i++ )
            {
                //fprintf(stderr, "          C%d wait sem pool C%d \n", id, i);
                //sem_wait(&sem_pool);
                //fprintf(stderr, "          C%d pass sem pool C%d \n", id, i);
                //pthread_cond_signal(&cond_var[i]);
            }
        }

        
        //binsem_wait(&binsem_cons[item & 255]);
        //pthread_cond_signal(&cond_var[item & 255]);


        ((struct ThreadData *) arg)->critical = false;
        pthread_mutex_unlock(&mutex_prod);


        fprintf(stderr, "C%d end\n", id);
        //printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)

        if (done)
            break;
    }
    printf("C%d stopped %lx\n", id, pthread_self());
    pthread_exit(NULL);
}




/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}

