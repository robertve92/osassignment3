/* 
 * Operating Systems  (2IN05)  Practical Assignment
 * Condition Variables Application
 *
 * STUDENT_NAME_1 (STUDENT_NR_1)
 * STUDENT_NAME_2 (STUDENT_NR_2)
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <pthread.h>
#include <semaphore.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM   buffer [BUFFER_SIZE];

static bool   bitmap [BUFFER_SIZE];

static unsigned int nrof_consumers = NROF_CONSUMERS;

static int prev = -1, next = -1;

static bool done = false, first = true;

static bool waiting[NROF_CONSUMERS];

struct ThreadData
{
    int id;
    bool critical;
};

pthread_cond_t cond_var[NROF_CONSUMERS];
pthread_cond_t cond_rdy[NROF_CONSUMERS];
pthread_cond_t cond_wait;
pthread_mutex_t mutex_prod;
pthread_mutex_t mutex_wait;
sem_t sem, sem_cons[NROF_CONSUMERS];

static void * producer (void * arg);
static void * consumer (void * arg);
static void rsleep (int t);

int main (void)
{
	printf("Producer / consumer 0.0.0\n");
	printf("%d Consumers\n", nrof_consumers);

	pthread_t p_producer;
	pthread_t p_consumer[nrof_consumers];
	int i;

    struct ThreadData * threadData[nrof_consumers];
    // allocate memory for thread data
    for( i = 0 ; i < nrof_consumers ; i++ )
    {
        threadData[i] = calloc(nrof_consumers, sizeof(struct ThreadData)); 
        threadData[i]->id = i;
        sem_init(&sem_cons[i], false, 1);
    }

    for ( i = 0; i < BUFFER_SIZE; i++ )
    {
        bitmap[i] = false;
    }

    sem_init(&sem, false, BUFFER_SIZE);

    /////////////////////////////////////////////
    // create threads
	pthread_create(&p_producer, NULL, producer, threadData);
	for (i = 0; i < nrof_consumers; i++)
	{
        waiting[i] = false;
		pthread_create(&p_consumer[i], NULL, consumer, threadData[i]);
	}
    /////////////////////////////////////////////
    // clean up threads
	int er = 0;
	if ( (er = pthread_join (p_producer, NULL ) ) != 0 )
	{
		perror("Error joining producer thread");
	}
    else
    {
        fprintf(stderr, "Producer joined %lx\n", p_producer);
    }
	for (i = 0; i < nrof_consumers; i++)
	{
		if ( ( er = pthread_join(p_consumer[i], NULL ) != 0 ) )
		{
			perror("Error joining consumer thread");
		}
        else
        {
            fprintf(stderr, "Consumer joined %lx, i: %d\n", p_consumer[i], i);
        }
	}  
    
    return (0);
}


/* producer thread */
static void * producer (void * arg)
{
	printf("Producer started %lx\n", pthread_self());
    ITEM    item;   // a produced item
    unsigned int count = 0, i, last = NROF_ITEMS + 1, ind;
    
    while (1/* TODO: not all items produced */)
    {
        rsleep (PRODUCER_SLEEP_FACTOR);
        
        item = random () % nrof_consumers;
        item |= (count << 8);

        // wait until there is room in the buffer
        sem_wait(&sem);
        pthread_mutex_lock(&mutex_prod);
        //fprintf(stderr, "item %04x, %x, %x\n",item, (item & (255 << 8)) >> 8, item & 255 );
        buffer[((item & (255 << 8)) >> 8) % BUFFER_SIZE] = item;
        bitmap[((item & (255 << 8)) >> 8) % BUFFER_SIZE] = true;

        for ( i = 0; i < BUFFER_SIZE; i++ )
        {// check if there is an older item in the buffer
            if ( ((buffer[i] & (255 << 8)) >> 8) < last && bitmap[i])
            {
                last = (buffer[i] & (255 << 8)) >> 8;
                ind = i;
            }
        }
        
        if (!((struct ThreadData **) arg)[ind]->critical)
        {
            prev = -1;
            pthread_cond_signal(&cond_var[buffer[ind] & 255]);
            fprintf(stderr, "P signalled C%d\n", buffer[ind] & 255);
            first = false;
        }
        
        pthread_mutex_unlock(&mutex_prod);


        printf("%04x\n", item); // write info to stdout
        if ( count++ == NROF_ITEMS )
        {
            break;
        }
    }
    printf("Producer stopped %lx\n", pthread_self());
    pthread_exit(NULL);
    // TODO: inform consumers that we're ready
}

/* consumer thread */
static void * consumer (void * arg)
{
	printf("Consumer started %lx\n", pthread_self());
    ITEM    item;   // a consstatic void * producer (void * arg)umed item
    int     id = ((struct ThreadData *) arg)->id;
    int     i, ind, semval;
    unsigned short int last = NROF_ITEMS + 1;

    
    while (1/* TODO: not all items retrieved for this customer */)
    {
        rsleep (100 * nrof_consumers);
        last = NROF_ITEMS + 1;
        // TODO: get the next item from buffer[] (intended for this customer)
        fprintf(stderr, "C%d waits for mutex\n", id);
        pthread_mutex_lock(&mutex_prod);
        fprintf(stderr, "C%d waits for cond\n", id);
        if (done)
        {
            break;
        }

        sem_getvalue(&sem_cons[id], &semval);
        if (semval == 0)
            sem_post(&sem_cons[id]);

        pthread_mutex_lock(&mutex_wait);
        pthread_cond_wait(&cond_var[id], &mutex_wait);
        pthread_mutex_unlock(&mutex_wait);

        sem_getvalue(&sem_cons[id], &semval);
        if (semval > 0)
            sem_wait(&sem_cons[id]);

        waiting[id] = false;
        fprintf(stderr, "C%d critical after C%d\n", id, prev);
        ((struct ThreadData *) arg)->critical = true;
        fprintf(
stderr, "       Buffer contents:\n");
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if (bitmap[i])
            {
                fprintf(
stderr, "       %04x %d\n", buffer[i], (buffer[i] & (255 << 8)) >> 8);
            }
            else
            {
                fprintf(
stderr, "       -111\n");
            }
        }
        
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {// check if there is an older item in the buffer
            if ( ((buffer[i] & (255 << 8)) >> 8) < last && bitmap[i])
            {
                last = (buffer[i] & (255 << 8)) >> 8;
                ind = i;
                fprintf(
stderr, "                     C%d checked %04x, last: %d\n", id, buffer[i], last);
            }
            
        }

        while (( buffer[ind] & 255 ) == id && bitmap[ind])
        {
            item = buffer[ind];
            bitmap[ind] = false;
            printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
            sem_post(&sem);
            ind = (ind += 1) % BUFFER_SIZE;
        }
        

        

        if ( ( (item & (255 << 8)) >> 8 ) == NROF_ITEMS - 1 )
        {
            done = true;
            for ( i = 0; i < nrof_consumers; i++ )
            {
                pthread_cond_signal(&cond_var[i]);
            }
            break;
        }
        ((struct ThreadData *) arg)->critical = false;
        pthread_mutex_unlock(&mutex_prod);

        fprintf(
stderr, "           C%d waiting for sem_post C%d\n", id, (buffer[ind] & 255));
        if (ind != id)
        {
            prev = id;
            sem_wait(&sem_cons[(buffer[ind] & 255)]);
            pthread_mutex_lock(&mutex_wait);
            pthread_cond_signal(&cond_var[(buffer[ind] & 255)]);
            pthread_mutex_unlock(&mutex_wait);
        }

        fprintf(stderr, "C%d end\n", id);
        //printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
    }
    printf("C%d stopped %lx\n", id, pthread_self());
    pthread_exit(NULL);
}




/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}

