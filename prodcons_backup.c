/* 
 * Operating Systems  (2IN05)  Practical Assignment
 * Condition Variables Application
 *
 * STUDENT_NAME_1 (STUDENT_NR_1)
 * STUDENT_NAME_2 (STUDENT_NR_2)
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <pthread.h>
#include <semaphore.h>

#include "prodcons.h"

/* buffer[]
 * circular buffer that holds the items generated by the producer and
 * which have to be retrieved by consumers
 */
static ITEM   buffer [BUFFER_SIZE];

static bool   bitmap [BUFFER_SIZE];

static unsigned int nrof_consumers = NROF_CONSUMERS;

static bool done = false;

#define ONEZ 65535
#define NROF_BITS_SEQ 16-NROF_BITS_DEST

struct ThreadData
{
    int id;
};

struct bin_sem {
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int v;
};

void binsem_init(struct bin_sem *p, int init_val)
{
    pthread_mutex_lock(&p->mutex);
    if (init_val > 0)
        p->v = 1;
    else if (init_val < 1)
        p->v = 0;
    pthread_mutex_unlock(&p->mutex);
}

void binsem_post(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    if (p->v == 0)
        p->v += 1;
    pthread_cond_signal(&p->cond);
    pthread_mutex_unlock(&p->mutex);
}

void binsem_depost(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    if (p->v == 1)
        p->v -= 1;
    pthread_cond_signal(&p->cond);
    pthread_mutex_unlock(&p->mutex);
}

void binsem_wait(struct bin_sem *p)
{
    pthread_mutex_lock(&p->mutex);
    while (!p->v)
        pthread_cond_wait(&p->cond, &p->mutex);
    p->v -= 1;
    pthread_mutex_unlock(&p->mutex);
}

pthread_cond_t cond_var[NROF_CONSUMERS];
pthread_mutex_t mutex_prod;
sem_t sem;

struct bin_sem binsem_cons[NROF_CONSUMERS];

static void * producer (void * arg);
static void * consumer (void * arg);
static void rsleep (int t);

int main (void)
{
    if (NROF_ITEMS == 0)
        return(0);

	//fprintf(stderr, "Producer / consumer 0.0.0\n");
	//fprintf(stderr, "%d Consumers\n", nrof_consumers);

	pthread_t p_producer;
	pthread_t p_consumer[nrof_consumers];
	int i;

    struct ThreadData * threadData[nrof_consumers];
    // allocate memory for thread data
    for( i = 0 ; i < nrof_consumers ; i++ )
    {
        //cond_var[i] = calloc(nrof_consumers, sizeof(pthread_cond_t));
        threadData[i] = calloc(nrof_consumers, sizeof(struct ThreadData)); 
        threadData[i]->id = i;
        binsem_init(&binsem_cons[i], 0);
    }

    for ( i = 0; i < BUFFER_SIZE; i++ )
    {
        bitmap[i] = false;
    }

    sem_init(&sem, false, BUFFER_SIZE);

    /////////////////////////////////////////////
    // create threads
    pthread_mutex_lock(&mutex_prod);
	pthread_create(&p_producer, NULL, producer, threadData);
	for (i = 0; i < nrof_consumers; i++)
	{
		pthread_create(&p_consumer[i], NULL, consumer, threadData[i]);
	}
    pthread_mutex_unlock(&mutex_prod);

    /////////////////////////////////////////////
    // clean up threads
	int er = 0;
	if ( (er = pthread_join (p_producer, NULL ) ) != 0 )
	{
		perror("Error joining producer thread");
	}
    else
    {
        //fprintf(stderr, "Producer joined %lx\n", p_producer);
    }
	for (i = 0; i < nrof_consumers; i++)
	{
		if ( ( er = pthread_join(p_consumer[i], NULL ) != 0 ) )
		{
			perror("Error joining consumer thread");
		}
        else
        {
            //fprintf(stderr, "Consumer joined %lx, i: %d\n", p_consumer[i], i);
        }
	}  
    
    return (0);
}


/* producer thread */
static void * producer (void * arg)
{
	fprintf(stderr, "Producer started %lx\n", pthread_self());
    ITEM    item;   // a produced item
    unsigned int count = 1, i, last = NROF_ITEMS + 1, ind;
    
    while (1/* TODO: not all items produced */)
    {

        rsleep (PRODUCER_SLEEP_FACTOR);
        
        item = random () % nrof_consumers;
        item &= ONEZ >> NROF_BITS_SEQ;
        item |= count << NROF_BITS_DEST;
        fprintf(stderr, "P count %d itemnr %d itemid %d item %04x\n", count, item >> NROF_BITS_DEST, item & (ONEZ >> NROF_BITS_SEQ), item);

        
        sem_wait(&sem);
        fprintf(stderr, "P waiting for mutex\n");
        pthread_mutex_lock(&mutex_prod);

        buffer[( item >> NROF_BITS_DEST ) % BUFFER_SIZE] = item;
        bitmap[( item >> NROF_BITS_DEST ) % BUFFER_SIZE] = true;
        printf("%04x\n", item);
        fprintf(stderr, "P dropping mutex\n");
        pthread_mutex_unlock(&mutex_prod);

        last = NROF_ITEMS + 1;
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if ( (buffer[i] >> NROF_BITS_DEST) < last && bitmap[i] )
            {
                last = (buffer[i] >> NROF_BITS_DEST);
                ind = i;
            }
        }

        binsem_post(&binsem_cons[buffer[ind] & (ONEZ >> NROF_BITS_SEQ)]);

        
        if ( count++ == NROF_ITEMS )
        {
            break;
        }
    }
    fprintf(stderr, "Producer stopped %lx\n", pthread_self());
    pthread_exit(NULL);
    // TODO: inform consumers that we're ready
}

/* consumer thread */
static void * consumer (void * arg)
{
	fprintf(stderr, "Consumer started %lx\n", pthread_self());
    ITEM    item;   // a consstatic void * producer (void * arg)umed item
    int     id = ((struct ThreadData *) arg)->id;
    int     i, ind;
    unsigned short int last = NROF_ITEMS + 1;

    
    while (1/* TODO: not all items retrieved for this customer */)
    {
        
        rsleep (100 * nrof_consumers);
        fprintf(stderr, "C%d waiting for binsem\n", id);
        binsem_wait(&binsem_cons[id]);
        if (done)
            break;
        fprintf(stderr, "C%d waiting for mutex\n", id);
        pthread_mutex_lock(&mutex_prod);
        fprintf(stderr, "C%d begin\n", id);
        
/*
        fprintf(stderr, "    buffer contents\n");
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if (bitmap[i])
            {
                fprintf(stderr, "     %04x %d\n", buffer[i], buffer[i] >> NROF_BITS_DEST );
            }
            else
            {
                fprintf(stderr, "     xxxx\n");
            }
        }
*/

        /////////////////////////////////////////////
        // critical section
        last = NROF_ITEMS + 1;
        for ( i = 0; i < BUFFER_SIZE; i++ )
        {
            if ( (buffer[i] >> NROF_BITS_DEST) < last && bitmap[i] )
            {
                last = buffer[i] >> NROF_BITS_DEST;
                ind = i;
            }
        }

        //fprintf(stderr, "C%d ind = %d and %d\n", id, ind, buffer[ind] & (ONEZ >> NROF_BITS_DEST));
        
        while ( (buffer[ind] & (ONEZ >> NROF_BITS_SEQ)) == id && bitmap[ind] )
        {
            item = buffer[ind];
            fprintf(stderr, "          C%d consumes %04x\n", id, item);
            bitmap[ind] = false;
            ind = (ind + 1) % BUFFER_SIZE;
            printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)
            sem_post(&sem);
        }
        if ( (buffer[ind] & (ONEZ >> (NROF_BITS_SEQ))) != id && bitmap[ind] )
        {
            fprintf(stderr, "          C%d signals C%d for %04x\n", id, buffer[ind] & (ONEZ >> NROF_BITS_SEQ), buffer[ind]);
            binsem_post(&binsem_cons[(buffer[ind] & (ONEZ >> (NROF_BITS_SEQ) ))]);
        }

        fprintf(stderr, "C%d dropping mutex\n", id);
        pthread_mutex_unlock(&mutex_prod);

        if ( (item >> NROF_BITS_DEST) >= NROF_ITEMS )
        {
            fprintf(stderr, "C%d CONSUMERS ARE NOW DONE %d %d\n", id, NROF_ITEMS, item >> NROF_BITS_DEST);
            done = true;
            for ( i = 0; i < nrof_consumers; i++)
            {
                binsem_post(&binsem_cons[i]);
            }
            
        }
       

        
        if (done)
            break;
        //fprintf(stderr, "C%d end critical section\n", id);
        //break;
        //printf("%*s    C%d:%04x\n", 7*id, "", id, item); // write info to stdout (with indentation)

        
    }
    fprintf(stderr, "C%d stopped %lx\n", id, pthread_self());
    pthread_exit(NULL);
}




/*
 * rsleep(int t)
 *
 * The calling thread will be suspended for a random amount of time between 0 and t microseconds
 * At the first call, the random generator is seeded with the current time
 */
static void rsleep (int t)
{
    static bool first_call = true;
    
    if (first_call == true)
    {
        srandom (time(NULL));
        first_call = false;
    }
    usleep (random () % t);
}

